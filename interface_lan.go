package ipmi

import (
	"bytes"
	"context"
	"crypto/md5"
	"encoding/binary"
	"fmt"
	"time"
)

const (
	RmcpVersion uint8 = 0x06

	IPMIVersion15 = 0x15
	IPMIVersion20 = 0x20

	RMCP_TYPE_MASK = 0x80
	RMCP_TYPE_NORM = 0x00
	RMCP_TYPE_ACK  = 0x01
)

// Rmcp holds the data that will be send over UDP
type Rmcp struct {
	// Multi-byte fields in RMCP/ASF fields are specified as being transmitted in "Network Byte Order" - meaning most-significant byte first.
	// RMCP and ASF-specified fields are therefore transferred **most-significant byte first**.
	RmcpHeader *RmcpHeader

	// Multi-byte fields in RMCP/ASF fields are specified as being transmitted in "Network Byte Order"
	ASF *ASF

	// The IPMI convention is to transfer multi-byte numeric fields least-significant Byte first. Therefore, unless otherwise specified:
	// Data in the IPMI Session Header and IPMI Message fields are transmitted **least-significant byte first**.
	Session15 *Session15
	Session20 *Session20
}

func (r *Rmcp) Pack() []byte {
	out := r.RmcpHeader.Pack()
	if r.ASF != nil {
		out = append(out, r.ASF.Pack()...)
	}
	if r.Session15 != nil {
		out = append(out, r.Session15.Pack()...)
	}
	if r.Session20 != nil {
		out = append(out, r.Session20.Pack()...)
	}
	return out
}

func (r *Rmcp) Unpack(msg []byte) error {
	if len(msg) < 4 {
		return ErrUnpackedDataTooShort
	}
	rmcpHeader := &RmcpHeader{}
	err := rmcpHeader.Unpack(msg[:4])
	if err != nil {
		return fmt.Errorf("unpack RmcpHeader failed, err: %s", err)
	}
	r.RmcpHeader = rmcpHeader

	if len(msg) < 4+1 {
		return fmt.Errorf("msg length too short, no session inside")
	}

	if r.RmcpHeader.MessageClass == MessageClassASF {
		asf := &ASF{}
		err := asf.Unpack(msg[4:])
		if err != nil {
			return fmt.Errorf("unpack ASF failed, err: %s", err)
		}
		r.ASF = asf
		return nil
	}

	authTypeOrFormat := msg[4]
	if authTypeOrFormat == byte(AuthTypeRMCPPlus) {
		// IPMI 2.0
		s20 := &Session20{}
		err = s20.Unpack(msg[4:])
		if err != nil {
			return fmt.Errorf("unpack IPMI 2.0 Session failed, err: %s", err)
		}
		r.Session20 = s20
	} else {
		// IPMI 1.5
		s15 := &Session15{}
		err = s15.Unpack(msg[4:])
		if err != nil {
			return fmt.Errorf("unpack IPMI 1.5 Session failed, err: %s", err)
		}
		r.Session15 = s15
	}

	if r.Session15 != nil && r.Session20 != nil {
		return fmt.Errorf("the IPMI session can not be both version 1.5 and 2.0")
	}

	return nil
}

// RmcpHeader represents RMCP Message Header
// 13.1.3
type RmcpHeader struct {
	// 06h = RMCP Version 1.0
	// IPMI-over-LAN uses version 1 of the RMCP protocol and packet format
	Version uint8

	// RMCP Messages with class=IPMI should be sent with an RMCP Sequence Number of FFh
	// to indicate that an RMCP ACK message should not be generated by the message receiver.
	SequenceNumber uint8

	// This field identifies the format of the messages that follow this header.
	// All messages of class ASF (6) conform to the formats defined in this
	// specification and can be extended via an OEM IANA.
	// Bit 7 RMCP ACK
	// 0 - Normal RMCP message
	// 1 - RMCP ACK message
	ACKFlag bool
	// Bit 6:5 Reserved
	// Bit 4:0 Message Class
	// 0-5 = Reserved
	// 6 = ASF
	// 7 = IPMI
	// 8 = OEM defined
	// all other = Reserved
	MessageClass MessageClass // Can be IPMI Messages, ASF, OEM
}

func NewRmcpHeader() *RmcpHeader {
	return &RmcpHeader{
		Version:        RmcpVersion,
		SequenceNumber: 0xff,
		MessageClass:   MessageClassIPMI,
	}
}

func NewRmcpHeaderASF() *RmcpHeader {
	return &RmcpHeader{
		Version:        RmcpVersion,
		SequenceNumber: 0xff,
		MessageClass:   MessageClassASF,
	}
}

func (r *RmcpHeader) Pack() []byte {
	msg := make([]byte, 4)
	packUint8(r.Version, msg, 0)
	// 1 byte reserved
	packUint8(r.SequenceNumber, msg, 2)

	var messageClass uint8 = 0x00
	if r.ACKFlag {
		messageClass |= 0x80
	} else {
		messageClass |= 0x00
	}
	messageClass |= uint8(r.MessageClass)
	packUint8(messageClass, msg, 3)
	return msg
}

func (r *RmcpHeader) Unpack(msg []byte) error {
	if len(msg) < 4 {
		return ErrUnpackedDataTooShort
	}

	r.Version, _, _ = unpackUint8(msg, 0)
	// 1 byte reserved
	r.SequenceNumber, _, _ = unpackUint8(msg, 2)

	var b uint8
	b, _, _ = unpackUint8(msg, 3)
	r.ACKFlag = isBit7Set(b)
	messageClass := b & 0x7f // clear the ACK bit
	r.MessageClass = MessageClass(messageClass)
	return nil
}

type MessageType uint8

const (
	MessageACKBit    uint8 = 0x80
	MessageNormalBit uint8 = 0x00
)

const (
	MessageTypeUndefined MessageType = 0x00
	MessageTypePing      MessageType = 0x80
	MessageTypeRMCPACK   MessageType = (0x80 | 6)
	MessageTypeASF       MessageType = (0x00 | 6)
	MessageTypeIPMI      MessageType = (0x00 | 7)
	MessageTypeOEM       MessageType = (0x00 | 8)
)

// the ACK/Normal Bit and the Message Class combine to identify the type of
// message under RMCP
// see: Table 13-, Message Type Determination Under RMCP
func (r *RmcpHeader) MessageType() MessageType {
	if r.ACKFlag {
		switch r.MessageClass {
		case MessageClassASF:
			return MessageTypeRMCPACK
		default:
			return MessageTypeUndefined
		}
	}

	switch r.MessageClass {
	case MessageClassASF:
		return MessageTypeASF
	case MessageClassOEM:
		return MessageTypeOEM
	case MessageClassIPMI:
		return MessageTypeIPMI
	default:
		return MessageTypeIPMI
	}
}

type MessageClass uint8

const (
	// 0-5 Reserved

	MessageClassASF  = 6
	MessageClassIPMI = 7
	MessageClassOEM  = 8

	// 9-15 Reserved
)

func (mc MessageClass) NormalACKFlag() bool {
	i := uint8(mc) & uint8(1) << 7
	return i == uint8(1)<<7
}

// 13.2.1 RMCP ACK Messages
type RmcpAckMessage struct {
	// Copied from received message
	Version uint8

	// Copied from received message
	SequenceNumber uint8

	// [7] - Set to 1 to indicate ACK packet
	// [6:0] - Copied from received message.
	ACKFlag      bool
	MessageClass MessageClass // Can be IPMI Messages, ASF, OEM
}

type ASF struct {
	IANA        uint32 // 4542
	MessageType uint8

	// 0-FEh, generated by remote console. This is an RMCP version of a sequence number.
	// Values 0-254 (0-FEh) are used for RMCP request/response messages.
	// 255 indicates the message is unidirectional and not part of a request/response pair.
	MessageTag uint8

	DataLength uint8 // 00h

	Data []byte
}

func (asf *ASF) Pack() []byte {
	msg := make([]byte, 8+len(asf.Data))
	packUint32(asf.IANA, msg, 0) // MSB, not LSB
	packUint8(asf.MessageType, msg, 4)
	packUint8(asf.MessageTag, msg, 5)
	// 1 byte reserved
	packUint8(asf.DataLength, msg, 7)
	packBytes(asf.Data, msg, 8)
	return msg
}

func (asf *ASF) Unpack(msg []byte) error {
	if len(msg) < 8 {
		return ErrUnpackedDataTooShort
	}

	asf.IANA, _, _ = unpackUint32L(msg, 0)
	asf.MessageType, _, _ = unpackUint8(msg, 4)
	asf.MessageTag, _, _ = unpackUint8(msg, 5)
	// 1 byte reserved
	asf.DataLength, _, _ = unpackUint8(msg, 7)

	if len(msg) < 8+int(asf.DataLength) {
		return ErrUnpackedDataTooShort
	}
	asf.Data, _, _ = unpackBytes(msg, 8, int(asf.DataLength))
	return nil
}

func (c *Client) BuildRmcpRequest(reqCmd Request) (*Rmcp, error) {
	payloadType, rawPayload, err := c.buildRawPayload(reqCmd)
	if err != nil {
		return nil, fmt.Errorf("buildRawPayload failed, err: %s", err)
	}
	c.DebugBytes("rawPayload", rawPayload, 16)

	// ASF
	if _, ok := reqCmd.(*RmcpPingRequest); ok {
		rmcp := &Rmcp{
			RmcpHeader: NewRmcpHeaderASF(),
			ASF: &ASF{
				IANA:        4542,
				MessageType: uint8(MessageTypePing),
				MessageTag:  0,
				DataLength:  0,
				Data:        rawPayload,
			},
		}
		return rmcp, nil
	}

	// IPMI 2.0
	if c.v20 {
		session20, err := c.genSession20(payloadType, rawPayload)
		if err != nil {
			return nil, fmt.Errorf("genSession20 failed, err: %s", err)
		}

		rmcp := &Rmcp{
			RmcpHeader: NewRmcpHeader(),
			Session20:  session20,
		}
		return rmcp, nil
	}

	// IPMI 1.5
	session15, err := c.genSession15(rawPayload)
	if err != nil {
		return nil, fmt.Errorf("genSession15 failed, err: %s", err)
	}

	rmcp := &Rmcp{
		RmcpHeader: NewRmcpHeader(),
		Session15:  session15,
	}
	return rmcp, nil
}

func genSessionTrailerPadLength(sessionHeader []byte, sessionPayload []byte) int {

	// (12) sessionHeader length
	// sessionPayload length
	// (1) pad length field
	// (1) next header field
	length := len(sessionHeader) + len(sessionPayload) + 1 + 1

	var padSize int = 0
	if length%4 != 0 {
		padSize = 4 - int(length%4)
	}
	return padSize
}

// genSessionTrailer will create the SessionTrailer.
//
// see 13.28.4 Integrity Algorithms
// Unless otherwise specified, the integrity algorithm is applied to the packet
// data starting with the AuthType/Format field up to and including the field
// that immediately precedes the AuthCode field itself.
func (c *Client) genSessionTrailer(sessionHeader []byte, sessionPayload []byte) (*SessionTrailer, error) {
	padSize := genSessionTrailerPadLength(sessionHeader, sessionPayload)
	var pad = make([]byte, padSize)
	for i := 0; i < padSize; i++ {
		pad[i] = 0xff
	}

	sessionTrailer := &SessionTrailer{
		IntegrityPAD: pad,
		PadLength:    uint8(padSize),
		NextHeader:   0x07, /* Hardcoded per the spec, table 13-8 */
		AuthCode:     nil,
	}

	var input []byte = sessionHeader
	input = append(input, sessionPayload...)
	input = append(input, sessionTrailer.IntegrityPAD...)
	input = append(input, sessionTrailer.PadLength)
	input = append(input, sessionTrailer.NextHeader)

	c.DebugBytes("auth code input", input, 16)

	authCode, err := c.genIntegrityAuthCode(input)
	if err != nil {
		return nil, fmt.Errorf("generate integrity authcode failed, err: %s", err)
	}

	c.DebugBytes("generated auth code", authCode, 16)

	sessionTrailer.AuthCode = authCode

	return sessionTrailer, nil
}

// the input data only represents the serialized ipmi msg request bytes.
// the output bytes contains the
//  - Confidentiality Header (clear text)
//  - Encrypted Payload.
//    - the cipher text of both rawPayload
//    - padded Confidentiality Trailer.
func (c *Client) encryptPlayload(rawPayload []byte, iv []byte) ([]byte, error) {

	switch c.session.v20.cryptAlg {
	case CryptAlg_None:
		return rawPayload, nil

	case CryptAlg_AES_CBC_128:
		// The input to the AES encryption algorithm has to be a multiple of the block size (16 bytes).
		// The extra byte we are adding is the pad length byte.
		var paddedData = rawPayload
		var padLength uint8
		if mod := (len(rawPayload) + 1) % int(Encryption_AES_CBS_128_BlockSize); mod > 0 {
			padLength = Encryption_AES_CBS_128_BlockSize - uint8(mod)
		} else {
			padLength = 0
		}
		for i := uint8(0); i < padLength; i++ {
			paddedData = append(paddedData, i+1)
		}
		paddedData = append(paddedData, padLength) // now, the length of data SHOULD be multiple of 16
		c.DebugBytes("padded data (before encrypt)", paddedData, 16)

		// see 13.29 Table 13-, AES-CBC Encrypted Payload Fields
		if len(iv) == 0 {
			iv = randomBytes(16) // Initialization Vector
		}
		c.DebugBytes("random iv", iv, 16)

		// see 13.29.2 Encryption with AES
		// AES-128 uses a 128-bit Cipher Key. The Cipher Key is the first 128-bits of key K2
		cipherKey := c.session.v20.k2[0:16]
		c.DebugBytes("cipher key (k2)", cipherKey, 16)

		encyptedPayload, err := encryptAES(paddedData, cipherKey, iv)
		if err != nil {
			return nil, fmt.Errorf("encrypt payload with AES_CBC_128 failed, err: %s", err)
		}
		c.DebugBytes("encrypted data", encyptedPayload, 16)

		var out []byte

		// write Confidentiality Header
		out = append(out, iv...)
		// write Encrypted Payload
		out = append(out, encyptedPayload...)

		c.DebugBytes("encrypted session payload", out, 16)

		return out, nil

	case CryptAlg_xRC4_40, CryptAlg_xRC4_128:
		var out []byte

		// see 13.30 Table 13-, xRC4-Encrypted Payload Fields
		var confidentialityHeader []byte
		var offset = make([]byte, 4)
		if c.session.v20.accumulatedPayloadSize == 0 {
			// means this is the first sent packet
			for i := 0; i < 4; i++ {
				offset[i] = 0
			}
			c.session.v20.rc4EncryptIV = array16(randomBytes(16))
			confidentialityHeader = append(offset, c.session.v20.rc4EncryptIV[:]...)
		} else {
			binary.BigEndian.PutUint32(offset, c.session.v20.accumulatedPayloadSize)
			confidentialityHeader = offset
		}

		c.session.v20.accumulatedPayloadSize += uint32(len(rawPayload))

		iv := c.session.v20.rc4EncryptIV[:]
		out = append(out, confidentialityHeader...)

		input := append(c.session.v20.k2, iv...)
		keyRC := md5.New().Sum(input)

		var cipherKey []byte
		switch c.session.v20.cryptAlg {
		case CryptAlg_xRC4_40:
			// For xRC4 using a 40-bit key, only the most significant forty bits of Krc are used
			cipherKey = keyRC[:5]

		case CryptAlg_xRC4_128:
			// For xRC4 using a 128-bit key, all bits of Krc are used for initialization
			cipherKey = keyRC[:16]
		}

		encyptedPayload, err := encryptRC4(rawPayload, cipherKey, iv)
		if err != nil {
			return nil, fmt.Errorf("encrypt payload with xRC4_40 or xRC4_128 failed, err: %s", err)
		}
		// write Encrypted Payload
		out = append(out, encyptedPayload...)
		// xRC4 does not use a confidentiality trailer.
		return out, nil

	default:

		return nil, fmt.Errorf("not supported encryption algorithm %x", c.session.v20.cryptAlg)
	}
}

// the input data is the encrypted session payload.
// the output bytes is the decrypted IPMI Message bytes with padding removed.
func (c *Client) decryptPayload(data []byte) ([]byte, error) {
	switch c.session.v20.cryptAlg {

	case CryptAlg_None:
		return data, nil

	case CryptAlg_AES_CBC_128:
		iv := data[0:16] // the first 16 byte is the initialization vector
		cipherText := data[16:]
		cipherKey := c.session.v20.k2[0:16]
		d, err := decryptAES(cipherText, cipherKey, iv)
		if err != nil {
			return nil, fmt.Errorf("decrypt payload with AES_CBC_128 failed, err: %s", err)
		}
		padLength := d[len(d)-1]
		dEnd := len(d) - int(padLength) - 1
		return d[0:dEnd], nil

	case CryptAlg_xRC4_40, CryptAlg_xRC4_128:
		// the first received packet
		if data[0] == 0x0 && data[1] == 0x0 && data[2] == 0x0 && data[3] == 0x0 {
			c.session.v20.rc4DecryptIV = array16(data[4:20])
		}

		iv := c.session.v20.rc4DecryptIV[:]
		input := append(c.session.v20.k2, iv...)
		keyRC := md5.New().Sum(input)
		var cipherKey []byte
		switch c.session.v20.cryptAlg {
		case CryptAlg_xRC4_40:
			// For xRC4 using a 40-bit key, only the most significant forty bits of Krc are used
			cipherKey = keyRC[:5]

		case CryptAlg_xRC4_128:
			// For xRC4 using a 128-bit key, all bits of Krc are used for initialization
			cipherKey = keyRC[:16]
		}

		payloadData := data[20:]
		b, err := decryptRC4(payloadData, cipherKey, iv)
		if err != nil {
			return nil, fmt.Errorf("decrypt payload with xRC4_128 failed, err: %s", err)
		}
		return b, nil

	default:
		return nil, fmt.Errorf("not supported encryption algorithm %0x", c.session.v20.cryptAlg)
	}
}

// buildRawPayload returns the PayloadType and the raw payload bytes for Command Request.
// Most command request is IPMI PayloadType, but some requests like RAKP messages are not.
func (c *Client) buildRawPayload(reqCmd Request) (PayloadType, []byte, error) {
	var payloadType PayloadType
	if _, ok := reqCmd.(*OpenSessionRequest); ok {
		payloadType = PayloadTypeRmcpOpenSessionRequest
	} else if _, ok := reqCmd.(*RAKPMessage1); ok {
		payloadType = PayloadTypeRAKPMessage1
	} else if _, ok := reqCmd.(*RAKPMessage3); ok {
		payloadType = PayloadTypeRAKPMessage3
	} else {
		payloadType = PayloadTypeIPMI
	}

	var rawPayload []byte
	switch payloadType {
	case
		PayloadTypeRmcpOpenSessionRequest,
		PayloadTypeRAKPMessage1,
		PayloadTypeRAKPMessage3:
		// Session Setup Payload Types

		rawPayload = reqCmd.Pack()

	case PayloadTypeIPMI:
		// Standard Payload Types
		ipmiReq, err := c.BuildIPMIRequest(reqCmd)
		if err != nil {
			return 0, nil, fmt.Errorf("BuildIPMIRequest failed, err: %s", err)
		}

		c.Debug(">>>> IPMI Request", ipmiReq)
		rawPayload = ipmiReq.Pack()
	}

	return payloadType, rawPayload, nil
}

// ParseRmcpResponse parses msg bytes.
// The response param should be passed as a pointer of the struct which implements the Response interface.
func (c *Client) ParseRmcpResponse(msg []byte, response Response) error {
	rmcp := &Rmcp{}
	if err := rmcp.Unpack(msg); err != nil {
		return fmt.Errorf("unpack rmcp failed, err: %s", err)
	}
	c.Debug("<<<<<< RMCP Response", rmcp)

	if rmcp.ASF != nil {
		if int(rmcp.ASF.DataLength) != len(rmcp.ASF.Data) {
			return fmt.Errorf("asf Data Length not equal")
		}
		if err := response.Unpack(rmcp.ASF.Data); err != nil {
			return fmt.Errorf("unpack asf response failed, err: %s", err)
		}
		return nil
	}

	if rmcp.Session15 != nil {
		ipmiPayload := rmcp.Session15.Payload

		ipmiRes := IPMIResponse{}
		if err := ipmiRes.Unpack(ipmiPayload); err != nil {
			return fmt.Errorf("unpack ipmiRes failed, err: %s", err)
		}
		c.Debug("<<<< IPMI Response", ipmiRes)

		ccode := ipmiRes.CompletionCode
		if ccode != 0x00 {
			return &ResponseError{
				completionCode: CompletionCode(ccode),
				description:    fmt.Sprintf("ipmiRes CompletaionCode (%#02x) is not normal: %s", ccode, StrCC(response, ccode)),
			}
		}

		// now ccode is 0x00, we can continue to deserialize response
		if err := response.Unpack(ipmiRes.Data); err != nil {
			return &ResponseError{
				completionCode: 0x00,
				description:    fmt.Sprintf("unpack response failed, err: %s", err),
			}
		}
	}

	if rmcp.Session20 != nil {
		sessionHdr := rmcp.Session20.SessionHeader20

		switch sessionHdr.PayloadType {
		case
			PayloadTypeRmcpOpenSessionResponse,
			PayloadTypeRAKPMessage2,
			PayloadTypeRAKPMessage4:
			// Session Setup Payload Types

			if err := response.Unpack(rmcp.Session20.SessionPayload); err != nil {
				return fmt.Errorf("unpack session setup response failed, err: %s", err)
			}
			return nil

		case PayloadTypeIPMI:
			// Standard Payload Types
			ipmiPayload := rmcp.Session20.SessionPayload
			if sessionHdr.PayloadEncrypted {
				c.DebugBytes("decrypting", ipmiPayload, 16)
				d, err := c.decryptPayload(rmcp.Session20.SessionPayload)
				if err != nil {
					return fmt.Errorf("decrypt session payload failed, err: %s", err)
				}
				ipmiPayload = d
				c.DebugBytes("decrypted", ipmiPayload, 16)
			}

			ipmiRes := IPMIResponse{}
			if err := ipmiRes.Unpack(ipmiPayload); err != nil {
				return fmt.Errorf("unpack ipmiRes failed, err: %s", err)
			}
			c.Debug("<<<< IPMI Response", ipmiRes)

			ccode := ipmiRes.CompletionCode
			if ccode != 0x00 {
				return &ResponseError{
					completionCode: CompletionCode(ccode),
					description:    fmt.Sprintf("ipmiRes CompletaionCode (%#02x) is not normal: %s", ccode, StrCC(response, ccode)),
				}
			}

			// now ccode is 0x00, we can continue to deserialize response
			if err := response.Unpack(ipmiRes.Data); err != nil {
				return &ResponseError{
					completionCode: 0x00,
					description:    fmt.Sprintf("unpack response failed, err: %s", err),
				}
			}
		}
	}

	return nil
}

func (c *Client) exchangeLAN(request Request, response Response) error {
	c.Debug(">> Command Request", request)

	rmcp, err := c.BuildRmcpRequest(request)
	if err != nil {
		return fmt.Errorf("build RMCP+ request msg failed, err: %s", err)
	}
	c.Debug(">>>>>> RMCP Request", rmcp)
	sent := rmcp.Pack()
	c.DebugBytes("sent", sent, 16)

	ctx := context.Background()
	recv, err := c.udpClient.Exchange(ctx, bytes.NewReader(sent))
	if err != nil {
		return fmt.Errorf("client udp exchange msg failed, err: %s", err)
	}
	c.DebugBytes("recv", recv, 16)

	if err := c.ParseRmcpResponse(recv, response); err != nil {
		// Warn, must directly return err.
		// The error returned by ParseRmcpResponse might be of *ResponseError type.
		return err
	}

	c.Debug("<< Commmand Response", response)
	return nil

}

// session holds data exchanged during Session Activation stage when using lan/lanplus interface.
// see: 13.14 IPMI v1.5 LAN Session Activation, 13.15 IPMI v2.0/RMCP+ Session Activation
type session struct {
	// filled after GetChannelAuthenticationCapabilities
	authType AuthType
	ipmiSeq  uint8
	v20      v20
	v15      v15
}

type v15 struct {
	// indicate whether or not the session is in Pre-Session stage,
	// that is between "GetSessionChallenge" and "ActivateSession"
	preSession bool

	// indicate whether or not the IPMI 1.5 session is activated.
	active bool

	maxPrivilegeLevel PrivilegeLevel
	sessionID         uint32

	// Sequence number that BMC wants remote console to use for subsequent messages in the session.
	// Remote console use "inSeq" and increment it when sending Request to BMC.
	// "inSeq" is first updated by returned ActivateSession response.
	inSeq uint32

	// "outSeq" is set by Remote Console to indicate the sequence number should picked by BMC.
	// 6.12.12 IPMI v1.5 Outbound Session Sequence Number Tracking and Handling.
	outSeq uint32

	challenge [16]byte
}

type v20 struct {
	// specific to IPMI v2 / RMCP+ sessions
	state    SessionState
	sequence uint32 // session sequence number

	// filled by RmcpOpenSessionRequest
	requestedAuthAlg      AuthAlg
	requestedIntegrityAlg IntegrityAlg
	requestedEncryptAlg   CryptAlg

	// filled by RmcpOpenSessionResponse
	// RMCP Open Session is used for exchanging session ids
	authAlg           AuthAlg
	integrityAlg      IntegrityAlg
	cryptAlg          CryptAlg
	maxPrivilegeLevel PrivilegeLevel // uint8 requestedRole sent in RAKP 1 message
	role              uint8          // whole byte of priviledge level in RAKP1, will be used for computing authcode of rakp2, rakp3
	consoleSessionID  uint32
	bmcSessionID      uint32

	// values required for RAKP messages

	// filed in rakp1
	consoleRand [16]byte // Random number generated by the console

	// filled after rakp2
	bmcRand         [16]byte // Random number generated by the BMC
	bmcGUID         [16]byte // bmc GUID
	sik             []byte   // SIK, session integrity key
	k1              []byte   // K1 key
	k2              []byte   // K2 key
	rakp2ReturnCode uint8    // will be used in rakp3 message

	// see 13.33
	// Kuid vs Kg
	//  - ipmi user password (the pre-shared key), known as Kuid, which are set using the Set User Password command.
	//  - BMC key, known as Kg, Kg is set using the Set Channel Security Keys command.
	bmcKey []byte

	accumulatedPayloadSize uint32

	// for xRC4 encryption
	rc4EncryptIV [16]byte
	rc4DecryptIV [16]byte
}

// 13.14
// IPMI v1.5 LAN Session Activation
// 1. RmcpresencePing - PMCPPresencePong
// 2. Get Channel Authentication Capabilities
// 3. Get Session Challenge
// 4. Activate Session
func (c *Client) Connect15() error {
	var (
		err            error
		channelNumber  uint8          = 0x0e // Eh = retrieve information for channel this request was issued on
		privilegeLevel PrivilegeLevel = PrivilegeLevelAdministrator
	)

	_, err = c.GetChannelAuthenticationCapabilities(channelNumber, privilegeLevel)
	if err != nil {
		return fmt.Errorf("GetChannelAuthenticationCapabilities failed, err: %s", err)
	}

	_, err = c.GetSessionChallenge()
	if err != nil {
		return fmt.Errorf("GetSessionChallenge failed, err: %s", err)
	}

	c.session.v15.preSession = true

	_, err = c.ActivateSession()
	if err != nil {
		return fmt.Errorf("ActivateSession failed, err: %s", err)
	}

	_, err = c.SetSessionPrivilegeLevel(c.session.v15.maxPrivilegeLevel)
	if err != nil {
		return fmt.Errorf("SetSessionPrivilegeLevel failed, err: %s", err)
	}

	go func() {
		c.keepSessionAlive(30)
	}()

	return nil

}

// see 13.15 IPMI v2.0/RMCP+ Session Activation
func (c *Client) Connect20() error {
	var (
		err error

		// 0h-Bh,Fh = specific channel number
		// Eh = retrieve information for channel this request was issued on
		channelNumber uint8 = 0x0e

		privilegeLevel PrivilegeLevel = PrivilegeLevelAdministrator
	)

	_, err = c.GetChannelAuthenticationCapabilities(channelNumber, privilegeLevel)
	if err != nil {
		return fmt.Errorf("cmd: Get Channel Authentication Capabilities failed, err: %s", err)
	}

	// Todo, retry for opensession/rakp1/rakp3
	_, err = c.OpenSession()
	if err != nil {
		return fmt.Errorf("cmd: RMCP+ Open Session failed, err: %s", err)
	}

	_, err = c.RAKPMessage1()
	if err != nil {
		return fmt.Errorf("cmd: rakp1 failed, err: %s", err)
	}

	_, err = c.RAKPMessage3()
	if err != nil {
		return fmt.Errorf("cmd: rakp3 failed, err: %s", err)
	}

	_, err = c.SetSessionPrivilegeLevel(c.session.v20.maxPrivilegeLevel)
	if err != nil {
		return fmt.Errorf("SetSessionPrivilegeLevel failed, err: %s", err)
	}

	go func() {
		c.keepSessionAlive(30)
	}()

	return nil
}

// ConnectAuto detects the IPMI version supported by BMC by using
// GetChannelAuthenticaitonCapabilities commmand, then decide to use v1.5 or v2.0
// for subsequent requests.
func (c *Client) ConnectAuto() error {
	var (
		err error

		// 0h-Bh,Fh = specific channel number
		// Eh = retrieve information for channel this request was issued on
		channelNumber uint8 = 0x0e

		privilegeLevel PrivilegeLevel = PrivilegeLevelAdministrator
	)

	// force use IPMI v1.5 first
	c.v20 = false
	cap, err := c.GetChannelAuthenticationCapabilities(channelNumber, privilegeLevel)
	if err != nil {
		return fmt.Errorf("cmd: Get Channel Authentication Capabilities failed, err: %s", err)
	}
	if cap.SupportIPMIv20 {
		c.v20 = true
		return c.Connect20()
	}
	if cap.SupportIPMIv15 {
		return c.Connect15()
	}
	return fmt.Errorf("client does not support IPMI v1.5 and IPMI v.20")
}

// closeLAN closes session used in LAN communication.
func (c *Client) closeLAN() error {
	var sessionID uint32
	if c.v20 {
		sessionID = c.session.v20.bmcSessionID
	} else {
		sessionID = c.session.v15.sessionID
	}

	request := &CloseSessionRequest{
		SessionID: sessionID,
	}
	if _, err := c.CloseSession(request); err != nil {
		return fmt.Errorf("CloseSession failed, err: %s", err)
	}

	if err := c.udpClient.Close(); err != nil {
		return fmt.Errorf("close udp connection failed, err: %s", err)
	}

	return nil
}

// 6.12.15 Session Inactivity Timeouts
func (c *Client) keepSessionAlive(intervalSec int) error {
	var period = time.Duration(intervalSec) * time.Second
	ticker := time.NewTicker(period)
	defer ticker.Stop()

	for range ticker.C {
		if _, err := c.GetCurrentSessionInfo(); err != nil {
			return fmt.Errorf("keepSessionAlive failed, GetCurrentSessionInfo failed, err: %s", err)
		}
	}
	return nil
}
